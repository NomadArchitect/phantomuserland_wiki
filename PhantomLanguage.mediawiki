Phantom programming laguage is a native language for Phantom applications code. There is also (incomplete) convertor from JVM to Phantom VM which permits use of JVM based languages in Phantom.

= Phantom language reference =


This document describes phantom programming language as planned at this moment, 10 March 2009.

Impatient? Read [[Phantom language differences from Java, C# and C++]]


== Structure ==

Phantom language is a quite classic object-style programming language. 

=== Objects, types ===

Everything is an object. Type (class) is object that is able to create objects. Class class is a root thing used to create classes.

=== Built in, atomic types ===

At this moment phantom VM is able to process objects of some predefined classes – integer, string, code, interface, class. All of them look like usual classes/objects, no special treatment from outside is needed. To be more effective VM is able to process integers separately, in a more effective way. Such integers are specific only during processing and stored as usual objects too.

=== Type checks ===

Phantom is a dynamically typed engine. Any object’s type can be (but is not) checked at runtime. Static type checks are done where possible, but in general it is possible to ignore types completely at compile time.

=== Exceptions ===

Any class can identify an exception (no special interface implementation is required, for example, for object to be thrown). Any object can be thrown, and catcher will catch it if object belongs to the type that catcher is looking for…

=== Calls, returns ===

Any number of arguments is passed, one or nothing is returned. Null object will be received if caller expects return value and called code did not return anything. (This is assumed to be impossible in a correct Phantom language program, but is possible technically.) If called code does not return some object explicitly, it is possible that some junk value will be returned. Static type checks are supposed to prevent this, but you can overcome.




To do: named arguments, such as

container.add( value => 5, position => iterator );

== Memory ==

Phantom language objects are dynamically (heap) allocated only. No automatic (stack) allocation possible, but stacks variables exist. No static variables exist, but you can use class variables to achieve effect akin to static variables (not implemented).


Phantom code is expected to be running in a persistent environment, but can be used in conventional environment too.

== Flow control ==

=== if ===

'''if(''' <integer-expression> ''')''' <operator-yes> ['''else''' <operator-no>]'''<nowiki>;</nowiki>'''


<u>Operator-yes</u> will be executed if <u>integer-expression</u> is non zero. If <u>operator-no</u> is given it will be executed if <u>integer-expression</u> is zero. If type of expression can not be checked at compile time, '''NO CHECKS''' will be done at runtime. Result is unpredictable. Don’t expect exception to be thrown.


+implemented, +tested.

=== while ===

'''while( '''<integer-expression> ''')''' <operator>


As long as <u>integer-expression</u> is nonzero, <u>operator</u> will be executed in loop. If type of expression can not be checked at compile time, '''NO CHECKS''' will be done at runtime. Result is unpredictable. Don’t expect exception to be thrown.


+implemented, +tested.

=== do-while ===

'''do '''<pre-operator>''' while( '''<integer-expression> ''')''' [<post-operator>]


Same as while, but <u>pre-operator</u> is executed before any condition check. If <u>post-operator</u> is omitted, we have a classical C-style do-while operator.


+implemented, -tested.

=== foreach ===

'''foreach(''' <variable> '''in''' <container-expression> ''')''' <operator>


<u>Operator</u> will be executed a number of times, and each time <u>variable</u> will be assigned a new element of <u>container-expression</u>. All elements will be iterated through. Order is defined by the container. Variable will be const.


-implemented, -tested.


Todo: “foreach(iterator) operator”

=== switch ===

'''switch( '''<expression>''' )'''

'''{'''


'''case''' <expression>:

// code

'''break;'''


'''default:'''

// if expression was 1 we’ll come here

'''break;'''

'''}'''






Your plain vanilla switch operator. Difference is that you can use any data type and non-constant cases. Integer and constants are MUCH more effective, though.


+-implemented (integers only), +tested.

=== return ===

'''return;'''

'''return '''<expression>'''<nowiki>;</nowiki>'''


Return from method, with or without value.


+implemented, +tested.

=== try-catch ===

'''try <'''operator>''' catch(''' <type-1> <variable-1> ''')''' <operator-1> {''' catch(''' <type-N> <variable-N> ''')''' <operator-N> }


If <u>operator</u> will raise an exception throwing value of such <u>type-1</u>, <u>operator-1</u> will be executed, with <u>variable-1</u> containing thrown value.


+implemented, -tested.

=== throw ===

'''throw '''<expression>'''<nowiki>;</nowiki>'''


Exception will be thrown and control will be passed to catching code.


+implemented, +tested.

=== assert ===

'''assert''' <expression> ['''throw''' <value-to-throw>];

'''assert '''['''typeof''']''' '''<expression> '''is''' <type-expression> ['''throw''' <value-to-throw>];


In a first form, throw will be executed if <u>expression</u> is zero. Second form checks for <u>expression</u> to be of a given type.


-implemented, -tested.

=== new ===

'''… <nowiki>= new</nowiki>''' <type> '''(''' [<constructor-parameters>] ''')'''<nowiki>;</nowiki>

'''… <nowiki>= new</nowiki>''' '''<nowiki>*(</nowiki>'''<type-expression>''')''' '''(''' [<constructor-parameters>] ''')'''<nowiki>;</nowiki>


In a first form, creates an object of a statically given type. Second form uses <u>type-expression</u> as class object. If expression type can not be checked at runtime, you have a chance of getting runtime exception (of object is not a class or args are of incorrect type).


+implemented, +tested.

== Variables ==

All and every variable and programmer-accessible object field in phantom is a reference. Integer in Phantom IS, unlike Java, an object.


Typeless variable can be declared like this:


var name;

var name[];


Statically typed variable is:


var name : <type_name>; // scalar variable

var name : <type_name>[]; // container


or:


<type_name> name; // scalar variable

<type_name>[] name; // container


(The last form is not implemented yet.)


Dynamically typed variable:


var name : *<type-defining-expression>;

var name : *<type-defining-expression>[];


Expression must evaluate to class (type) object. It will be checked at compile time if possible.


+implemented, except for the last form.








== Expressions ==

=== Assignment ===

<lvalue> '''<nowiki>=</nowiki>''' <expression>'''<nowiki>;</nowiki>'''


Usual = is a reference assignment operator.


var i1 = 5; // new integer object is created

var i2 = i1; // i2 is the same object as i1 now

i1 = 10; // i2 is 5 now! Not like Java!


Note that '''<nowiki>=</nowiki>''' operator works more like in C/C++, though it works with references, not values.


<lvalue> .'''<nowiki>=</nowiki>''' <expression>'''<nowiki>;</nowiki>'''


Value assignment. This is a shortcut for a method ‘assign’ (ordinal '''N - 11??''') of an object. Thing to kill if you like functional languages. Do we need to forbid it for integer and string objects?


- implemented, -tested.

=== Comparison ===

<lvalue> '''<nowiki>=</nowiki>''' <expression> ''':==''' <expression>'''<nowiki>;</nowiki>'''

<lvalue> '''<nowiki>=</nowiki>''' <expression> ''':!=''' <expression>'''<nowiki>;</nowiki>'''




Operator ''':==''' is reference comparison.


var i1 = 5; 

var i2 = i1; 

i1 = 5; 


i1 :== i2 // is false!


Note that :'''<nowiki>==</nowiki>''' operator works more like == in Java.


<expression> '''<nowiki>==</nowiki>''' <expression>

<expression> '''!=''' <expression>

<expression> >'''<nowiki>=</nowiki>''' <expression>

<expression> <'''<nowiki>=</nowiki>''' <expression>

<expression> > <expression>

<expression> < <expression>




Value comparison. This is a shortcut for a method ‘equals’ (ordinal '''N??''') of an any type object and internal operations for int and string. 


=== Import ===

String (binary array, in fact, but currently compiler treats it as a string) can be imported from some storage. This is a quick hack to make an easy way to bring binary data to phantom testing environment. Import will surely change or cease to exist later. But for now compiler accepts constructs of '''import “filename”''' form in place of string constant.


string wavdata;

wavdata = import “wink.wav”;

=== Composition/decomposition (not implemented) ===



var name[] = <value, …>;

<value, …> = name;




== Method call ==

=== Normal call ===

<lvalue> '''<nowiki>=</nowiki>''' <expression>.<method-name>'''('''<args>''');'''

=== Call by ordinal ===

<lvalue> '''<nowiki>=</nowiki>''' <expression>.<integer-constant-expression>'''('''<args>''');'''


All the methods internally are numbered. For very special system-programmer’s needs we have this non-recommended and non-safe way of calling things. Since method prototype is not known to compiler, no argument type checks are done. (Is it right? Usually we can find prototype by ordinal too…) Over more, most of things called this way will not check their arguments so if you pass them wrong, the exception you will get is not guaranteed to be descriptive enough.


== Class definition ==



'''class''' <class-name> {<extends-implements>}

'''{'''

{<variable-or-method-definition>}

'''};'''


<extends-implements> ::=

<extends> | <implements>


<extends> ::= extends <class-name>


<variable-or-method-definition> ::=

<variable-definition> |

<method-definition>


<method-definition> ::= 

<type-name> <method-name> '''('''<args>''')''' ['''['''<integer>''']''']

'''{''' <method-body> '''}'''


Construction [<integer>] after arguments is used to define which ordinal number precisely this method will get.




'''package''' <package-name> '''<nowiki>;</nowiki>'''


Defines current source file as a component of a named package. It is not required. If package is not defined, all class definitions must use absolute class names (starting with point).


package .ru.dz.test;


class test { … };


Or:


class .ru.dz.test.test { … };


== Inheritance and interfaces (partially implemented)  ==

Class can implement any number of interfaces:


class car implements .ru.dz.cars.general, .com.microsoft.docsource

{

…

};


Class can statically (in a quite effective way) inherit from one base class:


class car_truck extends car

{

…

};


Class can dynamically (by storing a reference and proxying methods) inherit from any number of base classes:


class car_truck extends car, .ru.dz.cars.truck_code

{

…

};


In this case first base class will be static base class and others – dynamic. (Not implemented. Only one base class can be given now,)

== Types ==

Type is either void, or class name reference with optional container modifier. Look at examples:


// error, variable can’t be void

var alpha : void; 


// scalar

var beta : .internal.integer; 

var beta : int; // '''int''' is shortcut for '''.internal.integer'''


// vector of strings, default implementation

var gamma : .internal.string [];

var gamma : string [];


// vector, own implementation (.local.my_vector is a class)

var gamma : .internal.string [.local.my_vector]; 


// vector of type, defined at runtime by class_variable.

var gamma : *class_variable [.local.my_vector]; 


// vector of strings, vector class is defined at runtime 

// by class_variable.

var gamma : .internal.string [*class_variable]; 






Type can be undefined at compile time.


// variable of unknown type

var alpha; 


== Precedence ==

. [] ()

<nowiki>= .=</nowiki>

|| && !

<nowiki>== != < > <= >=</nowiki>

:== :!=

+ -

<nowiki>* / %</nowiki>

| & ~


== Errors and plans ==

Do <class-name> and <type-name> mean the same in this document? (No, type is class with possible []s)


Constructor can have ‘regenerator’ semantics to let us automatically recreate object if it was lost intentionally (not saved on snap) or accidentally (disk error, network error).


Make-style object dependencies?


Automatic-like variables with a guaranteed finalizer call on out-of scope event? (It will be forbidden for them to be passed away from method, of course.)


When passing object reference losing its type, we shall replace its interface with a special one, which will check all argument types in runtime.


Shall class object have a method which returns class interface by index?


case ranges? case 1 … 5:


== Closures (not implemented) ==

Closure is a pair of object pointer and block of code. Closure can be passed as value and activated. Closure can have parameters (in this case we can call it anonymous method). Closure can use usual method as it’s code.


Need closure to get parameters from surrounding code? Implicit or explicit way?

== Functions (not implemented) ==

Class methods in Phantom Language are divided in two categories: functions and non-functions (actions?).


The difference is quite simple. Functions are always return value, but never modify any of arguments, including ‘this’.


Non-functions (actions?) can modify arguments and/or ‘this’ object, but can not return value.


Such a division makes Phantom a bit more functional-style language on the one side and is quite practical on the other: compiler can aggressively optimize expressions with functions – up to eliminating calls to them due to common subexpression merge. 


In addition this division clarifies code quite a bit. You can be sure that getting value from object you never modify it in any way.

== Events (not implemented) ==

Class can have special event fields.


class car 

{

eventcrash;

voiddo_crash { crash++; }

} mycar;


…


mycar.crash += { print(“My car is dead now!\n”); }


Event handlers (closures, assigned to events) can have one parameter, which will receive signaling object reference:


class car 

{

eventcrash;

voiddo_crash { crash++; }

} mycar;


…


mycar.crash += 

(car src) 

{ 

print(“My car (“+src.toString()+”) is dead now!\n”); 

}


Or:


class car 

{

eventcrash;

voiddo_crash { crash++; }

} mycar;


…


class garage

{

handle_crash(car src);

} my_garage;


…


mycar.crash += my_garage.handle_crash;




== Possible interface cast implementation ==

One can reduce object method reference’s method list by casting it to some interface of object’s class. Like:




interface .local.my.redonly 

{ 

string get_value(); 

};


class .local.my.readwrite implements .local.my.redonly

{ 

string get_value(); 

void set_value(string); 

};


var stuff = new .local.my.readwrite;


stuff.set_value(“hello, silent world”);


return (.local.my.redonly)stuff;




Now caller can not access set_value method. Returned object’s interface just has no reference to it. And cast to .local.my.readwrite will not return that reference back.


'''NB!''' It will be good to have




return (@const) stuff;




to strip all non-const methods, by the way.

== Class names reference ==

=== Internal classes ===

.internal.object– the root class

.internal.void– used in compiler to represent void. Interpreter does not meet it?

.internal.int– integer (immutable?)

.internal.string– string (immutable?)

.internal.class– class class

.internal.interface– contains VMT

.internal.code– object of this class contains executable code


Containers:


.internal.container.page– page of references used in containers

.internal.container.array– simple basic array, auto-resizes on store


Some other internal classes exist (istack/ostack, for example) but these are not accessible from programs.


.internal.thread– represents thread

.internal.ostack– object stack

.internal.istack– integer stack

.internal.estack– exceptions stack

.internal.call_frame– call frame

.internal.bootstrap– boot helper


= See also =

[[Phantom language possible attributes implementation]]

